<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kuune.org</title>
    <link>http://kuune.org/</link>
    <description>Recent content on kuune.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    
    <lastBuildDate>Thu, 29 Jan 2015 07:54:48 &#43;0900</lastBuildDate>
    <atom:link href="http://kuune.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>サイトをリニューアルした</title>
      <link>http://kuune.org/text/2015/01/29/site-renewal/</link>
      <pubDate>Thu, 29 Jan 2015 07:54:48 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2015/01/29/site-renewal/</guid>
      <description>&lt;p&gt;全面的に適当に作りなおしている（doing）。あとブログ的な何かは今後こちらに書いていく。&lt;br /&gt;
URL を見ると分かるが、blog ではなく text という呼称を使っている。blog というとちゃんと書かないといけないみたいなのが自分の中であって、text という呼称にすることによって何かを書くことへの障壁を下げた。&lt;/p&gt;

&lt;p&gt;技術的な話をすると、&lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; という Go で作られた静的サイトジェネレーターを使って構築したものを GitHub Pages でホストしていて、&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git push&lt;/code&gt; → Travis-CI でビルド → Travis-CI が &lt;code&gt;gh-pages&lt;/code&gt; に push → 公開&lt;/p&gt;

&lt;p&gt;みたいに デプロイを自動化してる。&lt;br /&gt;
Travis-CI が混んでる時はなかなか変更が反映されないという問題があるけど、まぁビルドが通ったら通知がくるようにしているし、そんなに急いで公開しないといけないものもないので許容できる。&lt;/p&gt;

&lt;p&gt;前のブログには Zenback とか AdSense とか貼ってたけど、割と目障りだったし、技術的な記事を読む人はそんなものクリックしないし、そもそも AdBlock とか使ってて見えてもいないだろうから外した。&lt;/p&gt;

&lt;p&gt;あと今のデザインの大枠は &lt;a href=&#34;http://blog.golang.org/&#34;&gt;http://blog.golang.org/&lt;/a&gt; のパクリです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golangでどんな json が返ってくるかわからない時に struct で定義するまでじゃないんだけど､ interface だと呼び出しが面倒なのどうしたらいいんだろう問題への一回答例</title>
      <link>http://kuune.org/text/2014/11/07/json-struct-interface-in-golang/</link>
      <pubDate>Fri, 07 Nov 2014 16:21:00 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/11/07/json-struct-interface-in-golang/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://konboi.hatenablog.com/entry/2014/11/07/155418&#34;&gt;http://konboi.hatenablog.com/entry/2014/11/07/155418&lt;/a&gt; これへの自分なりの回答です。元ブログのタイトルは const になってますが、多分 struct のことですかね。&lt;/p&gt;

&lt;p&gt;Golang では &lt;code&gt;var&lt;/code&gt; を使えば変数が定義できますが、このときに型を指定する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var name string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この型のところに struct を置いてやることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var user struct {
    Name string
    Age  int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よく考えればまぁできますよねという感じです。&lt;br /&gt;
これを応用すると、元ブログの例は下記のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;bytes&amp;quot;
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func main() {
    b := []byte(`{&amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;, &amp;quot;hoge&amp;quot;: {&amp;quot;fuga&amp;quot;: &amp;quot;hoga&amp;quot;}}`)
    dec := json.NewDecoder(bytes.NewReader(b))
    var jsonData struct {
        Foo  string `json:&amp;quot;foo&amp;quot;`
        Hoge struct {
            Fuga string `json:&amp;quot;fuga&amp;quot;`
        } `json:&amp;quot;hoge&amp;quot;`
    }
    dec.Decode(&amp;amp;jsonData)
    fmt.Println(jsonData)
    fmt.Println(jsonData.Hoge.Fuga)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/nTCdrMxYoQ&#34;&gt;http://play.golang.org/p/nTCdrMxYoQ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただしこの方法は本当にどんな内容が返ってくるか分からない時には使えない（例えば返ってくる json が {&amp;ldquo;foo&amp;rdquo;: &amp;ldquo;bar&amp;rdquo;} なのか {&amp;ldquo;bar&amp;rdquo;: &amp;ldquo;foo&amp;rdquo;} なのか分からない時など）のでその時は元の記事のように &lt;code&gt;interface{}&lt;/code&gt; で受け取って型アサーションしてやる必要があります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Migu という golang 用 DB スキーマのマイグレーションツールを作った話</title>
      <link>http://kuune.org/text/2014/10/29/migu/</link>
      <pubDate>Wed, 29 Oct 2014 17:53:44 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/10/29/migu/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/winebarrel/ridgepole&#34;&gt;Ridgepole&lt;/a&gt; インスパイアの golang 用 DB スキーマのマイグレーションツールを作りました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/naoina/migu&#34;&gt;https://github.com/naoina/migu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Migu は Ridgepole と同様に（バグが無い限り）冪等性が保証されています。&lt;br /&gt;
Ridgepole と違うところは、スキーマ定義を DSL ではなくて golang の struct で定義するところです。こうすることによって、モデル定義 ＝ スキーマ定義となるので DRY になります。&lt;/p&gt;

&lt;h2 id=&#34;使い方:4b4ff7f79111255303f954736a076f6f&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;下記を &lt;code&gt;schema.go&lt;/code&gt; というファイル名で保存します。ファイル名は何でもいいんですが、ここでは &lt;code&gt;schema.go&lt;/code&gt; を使います。package 名も何でも構いません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package schema

type User struct {
    Name string
    Age  int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に &lt;code&gt;migu_test&lt;/code&gt; というデータベースを &lt;code&gt;mysqladmin&lt;/code&gt; コマンドで作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysqladmin -u root create migu_test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは MySQL のパスワード無しの &lt;code&gt;root&lt;/code&gt; ユーザーでログインすることを想定しています。&lt;br /&gt;
データベースを作成したら &lt;code&gt;migu&lt;/code&gt; コマンドでマイグレーションを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;migu -u root sync migu_test schema.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行した結果、下記のように &lt;code&gt;migu_test&lt;/code&gt; に &lt;code&gt;user&lt;/code&gt; テーブルが作成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% mysql -u root migu_test -e &#39;desc user&#39;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| name  | varchar(255) | NO   |     | NULL    |       |
| age   | int(11)      | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではここから更に Migu のマイグレーションを試していきます。&lt;br /&gt;
先ほどの &lt;code&gt;schema.go&lt;/code&gt; を下記のように変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package schema

type User struct {
    Name string
    Age  uint
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Age int&lt;/code&gt; を &lt;code&gt;Age uint&lt;/code&gt; に変えました。&lt;br /&gt;
では再度 &lt;code&gt;migu&lt;/code&gt; コマンドでマイグレーションを実行して結果を確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% migu -u root sync migu_test schema.go
% mysql -u root migu_test -e &#39;desc user&#39;
+-------+------------------+------+-----+---------+-------+
| Field | Type             | Null | Key | Default | Extra |
+-------+------------------+------+-----+---------+-------+
| name  | varchar(255)     | NO   |     | NULL    |       |
| age   | int(10) unsigned | NO   |     | NULL    |       |
+-------+------------------+------+-----+---------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;age&lt;/code&gt; フィールドが &lt;code&gt;int(11)&lt;/code&gt; から &lt;code&gt;int(10) unsigned&lt;/code&gt; に変わっているのが分かるでしょうか？&lt;br /&gt;
このように、Migu ではスキーマ定義を変えてコマンドを実行すればマイグレーションができます。今までのようにマイグレーション用 SQL を書く必要はありません。&lt;br /&gt;
また、Migu の冪等性を確認するためにもう一度マイグレーションを実行してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% migu -u root sync migu_test schema.go
% mysql -u root migu_test -e &#39;desc user&#39;
+-------+------------------+------+-----+---------+-------+
| Field | Type             | Null | Key | Default | Extra |
+-------+------------------+------+-----+---------+-------+
| name  | varchar(255)     | NO   |     | NULL    |       |
| age   | int(10) unsigned | NO   |     | NULL    |       |
+-------+------------------+------+-----+---------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変わっていませんね。&lt;/p&gt;

&lt;p&gt;ちなみに golang は同じパッケージ内であれば struct 本体とメソッドが別々のファイルにあってもいいので、下記のようにスキーマ定義とモデルの実装を分離することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// schema.go
type User struct {
    Name string
    Age  int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// user.go
func (u *User) IsAlice() bool {
    return u.Name == &amp;quot;alice&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:4b4ff7f79111255303f954736a076f6f&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Migu を使うことで大量のマイグレーションファイルを書く必要が無くなり、DB スキーマの管理が非常に楽になる上に身長が 5 センチ伸び、恋人もできることがお分かりいただけたかと思います。&lt;br /&gt;
とはいえ、まだまだ粗削りで足りない部分も多いので、これからもっと改良していく必要があります。&lt;br /&gt;
というわけで、あなたの Pull Request をお待ちしております。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Travis-CI で Windows バイナリをテストする</title>
      <link>http://kuune.org/text/2014/08/20/test-windows-binary-on-travis-ci/</link>
      <pubDate>Wed, 20 Aug 2014 13:55:22 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/08/20/test-windows-binary-on-travis-ci/</guid>
      <description>&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p&gt;travis-ciでapi-getでwine突っ込んでやったらwindows環境でのテストできるのでは？&lt;/p&gt;&amp;mdash; 7017 (@naoina) &lt;a href=&#34;https://twitter.com/naoina/statuses/498832759981240321&#34;&gt;August 11, 2014&lt;/a&gt;&lt;/blockquote&gt;&lt;br /&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;できました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/naoina/travis-win-test&#34;&gt;https://github.com/naoina/travis-win-test&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: go

go:
  - 1.3

before_install:
  - sudo apt-get update -qq
  - sudo apt-get install -y wine

install:
  - gvm cross windows 386

script:
  - GOOS=windows GOARCH=386 go test -c
  - wine travis-win-test.test.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/naoina/travis-win-test/blob/master/.travis.yml&#34;&gt;https://github.com/naoina/travis-win-test/blob/master/.travis.yml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;宗教上の理由で Golang を使いましたが、MinGW などのクロスコンパイラを用いても同様にできると思います。&lt;/p&gt;

&lt;p&gt;このように Travis-CI を用いる場合でも Windows バイナリのテストが行えることが分かりましたので、Gopher の皆様におかれましては Golang のクロスコンパイルの手軽さを活かして Windows 対応をしてみてはいかがでしょうか？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kocha v0.5 リリースしました</title>
      <link>http://kuune.org/text/2014/07/24/kocha-v0.5/</link>
      <pubDate>Thu, 24 Jul 2014 10:56:39 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/07/24/kocha-v0.5/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/naoina/kocha&#34;&gt;https://github.com/naoina/kocha&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前のバージョンとは非互換になってます。というか v1.0 まではバンバン非互換の変更入れていくつもりなので、まともに使うのはオススメしません。&lt;br /&gt;
ですが、もしそれでも Kocha を使いたいという場合は、人柱になって最新のバージョンを追いつつ使うか、&lt;a href=&#34;http://labix.org/gopkg.in&#34;&gt;gopkg.in&lt;/a&gt; を使ったりしてバージョンを固定して使うことをおすすめします。&lt;/p&gt;

&lt;h2 id=&#34;v0-5-での変更点:b1dfc794bc679a9a118f8dfd32659438&#34;&gt;v0.5 での変更点&lt;/h2&gt;

&lt;h3 id=&#34;url-ルーターを-denco-にしました:b1dfc794bc679a9a118f8dfd32659438&#34;&gt;URL ルーターを denco にしました&lt;/h3&gt;

&lt;p&gt;以前までの URL ルーターを別に切り出して改良した &lt;a href=&#34;https://github.com/naoina/denco&#34;&gt;Denco&lt;/a&gt; を使うようにしました。&lt;br /&gt;
これにより URL ルーティングのパフォーマンスが上がり、メモリ使用量も大幅に改善されています。&lt;/p&gt;

&lt;h3 id=&#34;net-http-互換として使えるようになりました:b1dfc794bc679a9a118f8dfd32659438&#34;&gt;net/http 互換として使えるようになりました&lt;/h3&gt;

&lt;p&gt;今までは Kocha で作ったものは Kocha でしか動かせませんでしたが、内外的に大幅に変更を加えて &lt;a href=&#34;http://golang.org/pkg/net/http/#Handler&#34;&gt;http.Handler&lt;/a&gt; インターフェースを実装しました。&lt;br /&gt;
これによって他の &lt;code&gt;net/http&lt;/code&gt; 用ライブラリ（ミドルウェアとして処理を挟むものなど）と組み合わせて使えるようになりました。&lt;br /&gt;
これは &lt;a href=&#34;http://naoina.github.io/kocha/docs/advanced.html&#34;&gt;http://naoina.github.io/kocha/docs/advanced.html&lt;/a&gt; に軽く書いています。&lt;br /&gt;
なお v0.5 における非互換性は大体この変更のせいです。&lt;/p&gt;

&lt;h3 id=&#34;go-1-3-以降のみをサポートします:b1dfc794bc679a9a118f8dfd32659438&#34;&gt;Go 1.3 以降のみをサポートします&lt;/h3&gt;

&lt;p&gt;golang はどんどん開発が進んでいるので敢えて古いものを使う必要は今のところ無いので新しいもの使っていきましょう。&lt;/p&gt;

&lt;p&gt;というのは建前で、実際のところは Kocha の graceful restart の機能を &lt;a href=&#34;https://github.com/naoina/miyabi&#34;&gt;miyabi&lt;/a&gt; というライブラリとして再実装し直して Kocha で使っているのですが、この miyabi が Go 1.3 で &lt;code&gt;net/http&lt;/code&gt; に導入された機能を使っているからです。&lt;/p&gt;

&lt;h2 id=&#34;今後の予定:b1dfc794bc679a9a118f8dfd32659438&#34;&gt;今後の予定&lt;/h2&gt;

&lt;p&gt;ログ周りの再設計をします。後は session による flash 機構の実装をしようと思います。&lt;br /&gt;
そこまでできたら &lt;a href=&#34;http://vocanew.kuune.org&#34;&gt;ぼかにゅー&lt;/a&gt; や、この plog.la を Kocha で実装して、実際に使う際に必要な機能やデバッグをしていこうと考えています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gin Web Framework について</title>
      <link>http://kuune.org/text/2014/07/01/gin-web-framework/</link>
      <pubDate>Tue, 01 Jul 2014 11:14:16 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/07/01/gin-web-framework/</guid>
      <description>&lt;p&gt;golang の新しい WEB アプリケーションフレームワークである &lt;a href=&#34;http://gin-gonic.github.io/gin/&#34;&gt;Gin Web Framework&lt;/a&gt; が出たらしいです。&lt;br /&gt;
この Gin、スゴイことにあの &lt;a href=&#34;https://github.com/go-martini/martini&#34;&gt;Martini&lt;/a&gt; より 40 倍速いとの触れ込みです。&lt;br /&gt;
ですが、この部分ちょっと違います。&lt;/p&gt;

&lt;p&gt;まず、Martini と比べて &lt;strong&gt;何が&lt;/strong&gt; 40 倍速いのか、というところですが&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/image/dd59ea0d-11d3-5dca-915f-ddb148cb4abc.png&#34; alt=&#34;20140701105236.png&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;これ、HTTP ルーターの速度を測ってるんですね。速いですね。ちなみに &lt;em&gt;Check out the benchmark suite&lt;/em&gt; ってところからベンチマークリポジトリに飛べます。&lt;/p&gt;

&lt;p&gt;で、ここからが本題です。&lt;br /&gt;
Gin の HTTP ルーターは実は自前ではなく &lt;a href=&#34;https://github.com/julienschmidt/httprouter&#34;&gt;HttpRouter&lt;/a&gt; という他の方が作った爆速の HTTP ルーターを使っています。&lt;br /&gt;
つまり、Martini より 40 倍速いのは Gin 本体ではなく HttpRouter ということです。これはちゃんと &lt;a href=&#34;http://gin-gonic.github.io/gin/#features&#34;&gt;ここ&lt;/a&gt; の &lt;em&gt;Low Overhead Powerful API&lt;/em&gt; にも明記されています。&lt;br /&gt;
ソースコードをざっと読んだ限りだと HttpRouter をチューニングして使っているということもなさそうなので、Gin 自体が Martini よりも 40 倍速いというのとはちょっと違うと思います。&lt;br /&gt;
多分 Martini よりも速い部分はあるのでしょうが、40 times faster の大部分は HttpRouter が持っていると思います。&lt;br /&gt;
github の starts 的にはマーケティングに成功してるっぽいですが、他人のプロダクトに乗っかってそれを広告に使うというのは私個人としては正直気持ち悪いです。&lt;/p&gt;

&lt;p&gt;余談ですが、HttpRouter は &lt;a href=&#34;https://github.com/julienschmidt/httprouter/issues/12&#34;&gt;https://github.com/julienschmidt/httprouter/issues/12&lt;/a&gt; みたいなのがあるので、実用できるのか微妙な気がしています。&lt;br /&gt;
ちなみに私も &lt;a href=&#34;https://github.com/naoina/denco&#34;&gt;Denco&lt;/a&gt; という HTTP ルーターを作ってまして、興味があれば &lt;a href=&#34;http://naoina.plog.la/2014/06/12/183508686252&#34;&gt;前の記事&lt;/a&gt; をご覧ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使うエンジニア、作るエンジニア</title>
      <link>http://kuune.org/text/2014/06/27/engineers/</link>
      <pubDate>Fri, 27 Jun 2014 09:22:12 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/06/27/engineers/</guid>
      <description>

&lt;p&gt;ここでいう エンジニア とは ソフトウェアエンジニア のことです。&lt;/p&gt;

&lt;h2 id=&#34;使うエンジニア:dc54b6b4f578cbd01428b90e24adf075&#34;&gt;使うエンジニア&lt;/h2&gt;

&lt;p&gt;既存のものを組み合わせて作る。&lt;br /&gt;
足りないものや不満があるものに関しては、無いものは仕方ないと割り切る。あるいは出てくるまで待つ。&lt;br /&gt;
builder。&lt;/p&gt;

&lt;h2 id=&#34;作るエンジニア:dc54b6b4f578cbd01428b90e24adf075&#34;&gt;作るエンジニア&lt;/h2&gt;

&lt;p&gt;既存のものを組み合わせて作る。&lt;br /&gt;
足りないものや不満があるものに関しては、自分で作ってしまうか、改善するための パッチ/プルリクエスト を送る。&lt;br /&gt;
creator。&lt;/p&gt;

&lt;h2 id=&#34;言いたいこと:dc54b6b4f578cbd01428b90e24adf075&#34;&gt;言いたいこと&lt;/h2&gt;

&lt;p&gt;不満不平を言うだけでなく、それを解決、改善するようなモノを作ろう。ソフトウェアエンジニアは変えられる力を持っているのだから。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ッターン！と箸の持ち方</title>
      <link>http://kuune.org/text/2014/06/26/type-the-enter/</link>
      <pubDate>Thu, 26 Jun 2014 19:44:34 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/06/26/type-the-enter/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/image/ac81835c-3ec9-570e-bd3d-f6ef7bba97db.gif&#34; alt=&#34;20100218_1708335.gif&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;キーボードの Enter を目一杯力を入れて叩く人いますよね。アレと箸の持ち方が似てるなと思い立ったのでこのポエムを書いてます。&lt;/p&gt;

&lt;p&gt;ところで、私は箸が好きです。小学生の頃に自発的に正しい箸の持ち方を練習して、今ではかなり綺麗な持ち方をしていると自負しています。&lt;br /&gt;
青黒檀の 8000 円近くするマイ箸を箸袋と一緒に買ったり、とある居酒屋チェーン店でそれらを両方忘れて店を出てしまい、5 時間後に電話したら箸袋だけ出てきたとかいうことを言われたりするぐらい好きです。&lt;br /&gt;
金輪際その店には行かないと心に強く誓いました。&lt;s&gt;店が出す箸と色も違うし一緒に置いてたんだから無いわけねぇだろ&lt;/s&gt;&lt;/p&gt;

&lt;p&gt;閑話休題。&lt;/p&gt;

&lt;p&gt;キーボードの打ち方というのは、正しく打つためにはきちんと運指などを学ぶ必要があります。&lt;br /&gt;
通常、キーボードを日常的に打たない人の場合、全ての指を駆使して打つことはできません。大体人差し指だけか、人差し指と中指だけで打ちます。&lt;br /&gt;
これは、キーボードの打ち方は覚えようとしないかぎり覚えないということに他なりません。&lt;/p&gt;

&lt;p&gt;これは箸の持ち方と同じ問題です。&lt;br /&gt;
箸も正しく持つには学んで練習する必要があります。そうでなければあの持ち方は絶対に身に付きません。&lt;/p&gt;

&lt;p&gt;つまりこういうことです。&lt;br /&gt;
ッターン！とする人はキーボードの打ち方が正しくないのではないでしょうか？正しいキーボードの打ち方をしていれば、Enter は右手小指で叩くはずです。&lt;br /&gt;
小指というのは指の中でも力が入りにくく、弱い部分です。ですので、小指では Enter を強く叩くことができないはずです。仮に強く叩くとしても、続けていれば小指が痛くなり、やはり強く叩くことをやめるはずです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ-1:cb7008fb1779dcb0c62350a3c106dc31&#34;&gt;まとめ 1&lt;/h2&gt;

&lt;p&gt;みなさん箸を正しく持ちましょう。&lt;/p&gt;

&lt;h2 id=&#34;まとめ-2:cb7008fb1779dcb0c62350a3c106dc31&#34;&gt;まとめ 2&lt;/h2&gt;

&lt;p&gt;ッターン！で気分が良いのは本人だけです。周りからするとうるさいだけなのでやめましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Graceful shutdown と restart が出来る net/http コンパチのライブラリをつくった</title>
      <link>http://kuune.org/text/2014/06/26/miyabi/</link>
      <pubDate>Thu, 26 Jun 2014 12:00:43 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/06/26/miyabi/</guid>
      <description>&lt;p&gt;Miyabi&lt;br /&gt;
&lt;a href=&#34;https://github.com/naoina/miyabi&#34;&gt;https://github.com/naoina/miyabi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Graceful shutdown/restart というのは HTTP サーバーにおいて、張られたソケットをいきなり切ってサーバーを終了するのではなく、すでに accept されているソケットに対する処理を終えてから終了または再起動することをいいます。&lt;br /&gt;
これによってダウンタイム無しでサーバーの再起動ができるようになります。&lt;/p&gt;

&lt;p&gt;Golang には既に graceful shutdown/restart をするようなものが色々とありますが、Miyabi は &lt;code&gt;net/http&lt;/code&gt; と完全に互換性があるように作っています。&lt;br /&gt;
なので、単に &lt;code&gt;http.ListenAndServe&lt;/code&gt; を &lt;code&gt;miyabi.ListenAndServe&lt;/code&gt; に変えるだけで graceful shutdown/restart が出来るようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/image/2776dcd1-afa7-5a35-9cc5-7cbacae1acf4.gif&#34; alt=&#34;miyabi.gif&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;注意点として、graceful restart を実現するにあたってサーバープロセスをフォークするようになっています。起動する毎に副作用によって挙動が変わるようなモノだとまともに動かないのではないかと思います。&lt;br /&gt;
また、先日リリースされた Go 1.3 の機能を使っているので 1.2.x 以下では動作しません。みなさん既に Go 1.3 もしくは tip を使っているはずなので問題ないでしょう。&lt;/p&gt;

&lt;p&gt;それでは、よい Golang 日和を。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Denco 技術解説</title>
      <link>http://kuune.org/text/2014/06/17/commentary-of-denco/</link>
      <pubDate>Tue, 17 Jun 2014 17:52:45 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/06/17/commentary-of-denco/</guid>
      <description>

&lt;p&gt;今回は Golang 用の URL ルーターである &lt;a href=&#34;https://github.com/naoina/denco&#34;&gt;Denco&lt;/a&gt; の技術解説をしていきます。&lt;br /&gt;
その前にひとつ、お知らせがあります。Denco はこのたび URL ルーターから URL ルーター兼 HTTP request multiplexer となりました。つまり、&lt;a href=&#34;http://golang.org/pkg/net/http/#ServeMux&#34;&gt;http.ServeMux&lt;/a&gt; の代わりとして使えるようになりました。&lt;br /&gt;
詳しくは &lt;a href=&#34;https://github.com/naoina/denco/blob/master/README.md&#34;&gt;README&lt;/a&gt; を参照してください。&lt;/p&gt;

&lt;h2 id=&#34;基本戦略:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;基本戦略&lt;/h2&gt;

&lt;p&gt;まず始めに、Denco のルーティングは静的パス（&lt;code&gt;/user/alice&lt;/code&gt; みたいなの）とパラメーター付きパス（&lt;code&gt;/user/:name&lt;/code&gt; みたいなの）で使用するアルゴリズムを変えています。&lt;br /&gt;
静的パスの場合は Go の map を使い、パラメーター付きパスの場合はパラメーターを扱えるように拡張したダブル配列を使います。これは、静的パスの場合、ダブル配列で処理するより Go の map を使ったほうが速いからです。&lt;br /&gt;
ですが、パラメーター付きパスは Go の map では扱えないので、拡張したダブル配列を使うことになります。今回はこのダブル配列の拡張についての解説です。&lt;/p&gt;

&lt;p&gt;ダブル配列というのは &lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%82%A4%E6%9C%A8&#34;&gt;Trie&lt;/a&gt; という主に文字列検索に使われるデータ構造の実装方法のひとつで、Trie の実装の中では最速の部類に入るものです。&lt;br /&gt;
詳しい概要については &lt;a href=&#34;http://nanika.osonae.com/DArray/dary.html&#34;&gt;http://nanika.osonae.com/DArray/dary.html&lt;/a&gt; や &lt;a href=&#34;http://d.hatena.ne.jp/takeda25/20120219/1329634865&#34;&gt;http://d.hatena.ne.jp/takeda25/20120219/1329634865&lt;/a&gt; を参照してください。&lt;br /&gt;
以下からはダブル配列を理解している前提での解説になります。&lt;/p&gt;

&lt;h2 id=&#34;拡張ダブル配列:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;拡張ダブル配列&lt;/h2&gt;

&lt;p&gt;さて、ダブル配列は速い Trie の実装ではありますが、静的な文字列に対するものなのでパラメーター付きパスのような特定の文字に意味を持たせるということがそのままではできません。&lt;br /&gt;
そこで、Denco では構築時およびルックアップ時にメタ文字である &lt;code&gt;:&lt;/code&gt; と &lt;code&gt;*&lt;/code&gt; を特別扱いするようにダブル配列を拡張しています。&lt;/p&gt;

&lt;h3 id=&#34;シングルパラメーター:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;シングルパラメーター&lt;/h3&gt;

&lt;p&gt;まず Denco の仕様として &lt;code&gt;/user/:name/:id&lt;/code&gt; などの &lt;code&gt;:name&lt;/code&gt; や &lt;code&gt;:id&lt;/code&gt; の部分は任意の文字列にマッチします。マッチする長さは次の &lt;code&gt;/&lt;/code&gt; が現れるまでか、終端までです。&lt;br /&gt;
例えば &lt;code&gt;/user/:name/:id&lt;/code&gt; に対して &lt;code&gt;/user/alice/1&lt;/code&gt; でマッチを試みた場合、&lt;code&gt;:name&lt;/code&gt; には &lt;code&gt;alice&lt;/code&gt; が、&lt;code&gt;:id&lt;/code&gt; には &lt;code&gt;1&lt;/code&gt; がマッチします。&lt;/p&gt;

&lt;h4 id=&#34;構築:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;構築&lt;/h4&gt;

&lt;p&gt;まず構築に使用する文字列は &lt;strong&gt;レコード&lt;/strong&gt; と呼びます。レコードには文字列の他にパラメーター名を保持するスライスをフィールドとして持たせます。&lt;br /&gt;
ダブル配列の構築では先頭から 1 文字ずつ見て構築していくのですが、Denco ではこのとき、&lt;code&gt;:&lt;/code&gt; という文字が現れた場合、次の &lt;code&gt;/&lt;/code&gt; の前、または終端まで読み込みます。&lt;br /&gt;
&lt;code&gt;/user/:name/:id&lt;/code&gt; であれば、最初の &lt;code&gt;:&lt;/code&gt; が現れたとき &lt;code&gt;:&lt;/code&gt; から次の &lt;code&gt;/&lt;/code&gt; の前まで読み込み、&lt;code&gt;:name&lt;/code&gt; という文字列を得ます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:&lt;/code&gt; はメタ文字なので、そのあとの &lt;code&gt;name&lt;/code&gt; が実際のパラメーターの名前になります。こうして得たパラメーターの名前をレコードのパラメーター名を保持するスライスに追加します。&lt;br /&gt;
また、レコード自体は参照時には使用しなくなるので、参照時に使用する BASE/CHECK の配列の要素にシングルパラメーターであるというフラグを立てておきます。&lt;br /&gt;
これで構築におけるシングルパラメーターの処理は終了なので、通常のダブル配列の構築に戻ります。&lt;br /&gt;
&lt;code&gt;/user/:name/:id&lt;/code&gt; というレコードを構築すると、上記処理によって &lt;code&gt;/user/:/:&lt;/code&gt; として構築され、&lt;code&gt;:&lt;/code&gt; の位置に対応する BASE/CHECK 配列の要素にはシングルパラメーターであるというフラグが立っていることになります。&lt;/p&gt;

&lt;p&gt;レコードの終端まで処理が終わればレコードに対するデータを実際に保持するノードを生成し、そのノードにパラメーター名を保持するスライスをレコードからコピーします。&lt;br /&gt;
このノードは専用の配列に格納され、ルックアップに成功した場合に対応するノードが取り出されますが、今回は割愛します。&lt;/p&gt;

&lt;h4 id=&#34;ルックアップ:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;ルックアップ&lt;/h4&gt;

&lt;p&gt;まず、&lt;code&gt;/user/:name/:id&lt;/code&gt; というレコードは &lt;code&gt;/user/:/:&lt;/code&gt; として構築されています。これに対して &lt;code&gt;/user/alice/1&lt;/code&gt; という文字列のルックアップを試みると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/user/:/:

/
/u
/us
/use
/user
/user/
/user/a ← a と : は違うので失敗！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;始めは BASE/CHECK 配列を使って普通にダブル配列のルックアップをしていきます。すると上記のように &lt;code&gt;:&lt;/code&gt; の場所で失敗します。&lt;br /&gt;
通常のダブル配列ならば失敗した時点でその文字列は無いということになるのですが、Denco では下記のように処理を続けます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;失敗した時点での BASE/CHECK 配列の要素のシングルパラメーターかどうかのフラグを調べる&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;シングルパラメーターでない場合、後述するワイルドカードパラメーターのチェックに移る&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ワイルドカードパラメーターのチェックも失敗した場合、ルックアップは失敗する&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;シングルパラメーターの場合、現在の位置から次の &lt;code&gt;/&lt;/code&gt; の前、または終端まで読み込みパラメーターとする&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;読み込んだあとからダブル配列のルックアップを再開&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;上記を繰り返し、最後まで読んだら終了&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/user/:/:

/
/u
/us
/use
/user
/user/
/user/a ←失敗！

      v ←現在位置
/user/a → 現在の位置がシングルパラメーターであるかをチェック

  ↓ /user/: の部分にあたるので現在位置はシングルパラメーター

/user/alice → &amp;quot;alice&amp;quot; を読み込みパラメーターとする

           v ←再開位置
/user/alice/
/user/alice/1 ←失敗！

            v ←現在位置
/user/alice/1 → 現在の位置がシングルパラメーターであるかをチェック

    ↓ /user/:/: の部分にあたるので現在位置はシングルパラメーター

/user/alice/1 → &amp;quot;1&amp;quot; を読み込みパラメーターとする

最後まで読んだので終了 → /user/alice/1 はマッチ、&amp;quot;name&amp;quot; パラメーターの値は &amp;quot;alice&amp;quot;、&amp;quot;id&amp;quot; パラメーターの値は &amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ワイルドカードパラメーター:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;ワイルドカードパラメーター&lt;/h3&gt;

&lt;h4 id=&#34;構築-1:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;構築&lt;/h4&gt;

&lt;p&gt;ほぼシングルパラメーターと同様ですが &lt;code&gt;*&lt;/code&gt; という文字が現れた場合、ワイルドカードパラメーターとして扱います。&lt;br /&gt;
シングルパラメーターのときは次の &lt;code&gt;/&lt;/code&gt; の前、または終端まで読み込みますが、Denco のワイルドカードパラメーターの場合は常に終端まで読み込みます。&lt;br /&gt;
ですので、&lt;code&gt;/static/*filepath&lt;/code&gt; というレコードの場合 &lt;code&gt;filepath&lt;/code&gt; がパラメーターの名前になりますが、&lt;code&gt;/static/*filepath/robots.txt&lt;/code&gt; とあった場合は &lt;code&gt;filepath/robots.txt&lt;/code&gt; が名前になってしまいますので注意してください。&lt;/p&gt;

&lt;p&gt;また、参照時に使用する BASE/CHECK の配列の要素にはワイルドカードパラメーターであるというフラグを立てます。&lt;br /&gt;
&lt;code&gt;/static/*filepath&lt;/code&gt; というレコードを構築すると &lt;code&gt;/static/*&lt;/code&gt; として構築されます。&lt;/p&gt;

&lt;h4 id=&#34;ルックアップ-1:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;ルックアップ&lt;/h4&gt;

&lt;p&gt;シングルパラメーターでのルックアップとほぼ同様ですが、失敗した際にワイルドカードパラメーターの場合は常に終端まで読み込まれ、それがパラメーターの値になります。&lt;br /&gt;
&lt;code&gt;/static/image/logo.png&lt;/code&gt; という文字列をルックアップすると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/static/*filepath

/
/s
/st
/sta
/stat
/stati
/static
/static/
/static/i ←失敗！

        v ←現在位置
/static/i → 現在の位置がワイルドカードパラメーターであるかをチェック

    ↓ /static/* の部分にあたるので現在位置はワイルドカードパラメーター

/static/image/logo.png → &amp;quot;image/logo.png&amp;quot; を読み込みパラメーターとする

最後まで読んだので終了 → /static/image/logo.png はマッチ、&amp;quot;filepath&amp;quot; パラメーターの値は &amp;quot;image/logo.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シングルパラメーターとワイルドカードパラメーターの優先順位は シングルパラメーター &amp;gt; ワイルドカードパラメーター です。&lt;br /&gt;
例えば &lt;code&gt;/user/:name&lt;/code&gt; と &lt;code&gt;/user/*any&lt;/code&gt; というレコードがあった場合、&lt;code&gt;/user/alice&lt;/code&gt; は &lt;code&gt;/user/:name&lt;/code&gt; にマッチします。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:e2e2057d4c670e3dac128efc565a5afc&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Denco ではどのようにしてダブル配列を拡張してパラメーターを扱えるようにしているかをざっくりと解説しました。&lt;br /&gt;
実際には今回解説した処理に加えてバックトラックによるパラメーターマッチをしています。バックトラックを行うことによって &lt;code&gt;/user/:name/:id&lt;/code&gt; と &lt;code&gt;/user/alice/:id&lt;/code&gt; のようなレコードを一緒に扱うことができるようになっています。&lt;br /&gt;
興味があればソースを読んでみてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>世界最速だった URL ルーターをリリースしました</title>
      <link>http://kuune.org/text/2014/06/12/denco/</link>
      <pubDate>Thu, 12 Jun 2014 18:35:08 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/06/12/denco/</guid>
      <description>

&lt;p&gt;Golang 用 URL ルーター &lt;a href=&#34;https://github.com/naoina/denco&#34;&gt;Denco&lt;/a&gt; をリリースしました。&lt;br /&gt;
ちょっと前までは最速でしたが、&lt;a href=&#34;https://github.com/julienschmidt/httprouter&#34;&gt;HttpRouter&lt;/a&gt; の作者によって高速にバックミラーから消し去られました。&lt;br /&gt;
ですが、HttpRouter ではできないことが Denco にできたりしますしおすし。&lt;br /&gt;
ベンチマークは &lt;a href=&#34;https://github.com/julienschmidt/go-http-routing-benchmark&#34;&gt;https://github.com/julienschmidt/go-http-routing-benchmark&lt;/a&gt; からどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;denco-とは:1d2dcdaa7033e85236908854dc845bef&#34;&gt;Denco とは&lt;/h2&gt;

&lt;p&gt;既に開発していた &lt;a href=&#34;https://github.com/naoina/kocha-urlrouter&#34;&gt;kocha-urlrouter&lt;/a&gt; のダブル配列実装をベースに色々と手を加えたものになります。&lt;br /&gt;
速度を重視して開発してましたが、前述の通り HttpRouter に追いぬかれました。&lt;/p&gt;

&lt;h2 id=&#34;使い方:1d2dcdaa7033e85236908854dc845bef&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;下記のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;router := denco.New()
router.Build([]denco.Record{
    {&amp;quot;/&amp;quot;, &amp;quot;root&amp;quot;},
    {&amp;quot;/user/:id&amp;quot;, 1024},
    {&amp;quot;/user/:name/:id&amp;quot;, []string{&amp;quot;username&amp;quot;}},
    {&amp;quot;/static/*filepath&amp;quot;, &amp;quot;static&amp;quot;},
})
data, params, found := router.Lookup(&amp;quot;/&amp;quot;)
fmt.Printf(&amp;quot;%v\n&amp;quot;, data.(string))
data, params, found = router.Lookup(&amp;quot;/user/1&amp;quot;)
fmt.Printf(&amp;quot;%v, %v = %v\n&amp;quot;, data.(int), params[0].Name, params[0].Value)
data, params, found = router.Lookup(&amp;quot;/user/naoina/2&amp;quot;)
fmt.Printf(&amp;quot;%v\n&amp;quot;, data.([]string))
for _, v := range params {
    fmt.Printf(&amp;quot;%v = %v\n&amp;quot;, v.Name, v.Value)
}
data, params, found = router.Lookup(&amp;quot;/static/path/to/other&amp;quot;)
fmt.Printf(&amp;quot;%v, %v = %v\n&amp;quot;, data, params[0].Name, params[0].Value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;README にも書いてあるんですが、Go の &lt;a href=&#34;http://golang.org/pkg/net/http/#ServeMux&#34;&gt;http.ServeMux&lt;/a&gt; を置き換えるものではないので、&lt;a href=&#34;http://golang.org/pkg/net/http/#Handler&#34;&gt;http.Handler&lt;/a&gt;  インターフェースは提供していません。&lt;br /&gt;
ですので、HandlerFunc などを呼ぶためのグルーコードを書く必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;

    &amp;quot;github.com/naoina/denco&amp;quot;
)

type handler struct {
    router *denco.Router
}

type handlerFunc func(http.ResponseWriter, *http.Request, []denco.Param)

func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    m, params, found := h.router.Lookup(r.RequestURI)
    if !found {
        panic(&amp;quot;route not found&amp;quot;)
    }
    m.(handlerFunc)(w, r, params)
}

func Index(w http.ResponseWriter, r *http.Request, _ []denco.Param) {
    fmt.Fprint(w, &amp;quot;Welcome!\n&amp;quot;)
}

func Hello(w http.ResponseWriter, r *http.Request, params []denco.Param) {
    fmt.Fprintf(w, &amp;quot;hello, %s!\n&amp;quot;, params)
}

func main() {
    router := denco.New()
    if err := router.Build([]denco.Record{
        {&amp;quot;/&amp;quot;, handlerFunc(Index)},
        {&amp;quot;/hello/naoina&amp;quot;, handlerFunc(Hello)},
        {&amp;quot;/hello/:name&amp;quot;, handlerFunc(Hello)},
    }); err != nil {
        panic(err)
    }
    h := &amp;amp;handler{router}
    log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, h))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはそもそも &lt;a href=&#34;https://github.com/naoina/kocha&#34;&gt;Kocha&lt;/a&gt; で使うために書き始めたものなので上記のようになっています。&lt;/p&gt;

&lt;h2 id=&#34;vs-httprouter:1d2dcdaa7033e85236908854dc845bef&#34;&gt;vs HttpRouter&lt;/h2&gt;

&lt;p&gt;再び最速の座を手に入れるべく頑張っていますが、現状では HttpRouter とほぼダブルスコアです。。。社会は厳しい！&lt;br /&gt;
ですが、Denco にしかできないことがあります。&lt;br /&gt;
例えば、HttpRouter では &lt;code&gt;/user/:name&lt;/code&gt; と &lt;code&gt;/user/naoina&lt;/code&gt; など、パラメーター付きパスと静的パスがかぶるようなルートが一緒に使えず、構築時に panic するようになっていますが、Denco だと問題ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;router.Build([]denco.Record{
    {&amp;quot;/user/:name&amp;quot;, &amp;quot;first&amp;quot;},
    {&amp;quot;/user/naoina&amp;quot;, &amp;quot;second&amp;quot;},
})
router.Lookup(&amp;quot;/user/hoge&amp;quot;) // &amp;quot;first&amp;quot;
router.Lookup(&amp;quot;/user/foo&amp;quot;) // &amp;quot;first&amp;quot;
router.Lookup(&amp;quot;/user/naoina&amp;quot;) // &amp;quot;second&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁ、負け惜しみです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:1d2dcdaa7033e85236908854dc845bef&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;私が調べた限りだと、ダブル配列を使った URL ルーターの実装というものがありませんでした。&lt;br /&gt;
ですので、参考になるか分かりませんが、次回から Denco の技術解説みたいなのを書こうかなと考えています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kocha が v0.3 になりました</title>
      <link>http://kuune.org/text/2014/03/14/kocha-v0.3/</link>
      <pubDate>Fri, 14 Mar 2014 09:50:19 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/03/14/kocha-v0.3/</guid>
      <description>

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt; でバージョン指定できないのにバージョン付ける意味あんのかよみたいな話はあると思いますが、Kocha &lt;a href=&#34;https://github.com/naoina/kocha&#34;&gt;https://github.com/naoina/kocha&lt;/a&gt; に v0.3 のタグを付けました。&lt;/p&gt;

&lt;p&gt;主な変更点は&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;モデル、ORM、マイグレーションなどのデータベース周りのサポート&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; や &lt;code&gt;prod&lt;/code&gt; などの環境ごとの設定の廃止&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;データベース周りのサポート:a76806e52f0d348474f1d7c3e490e072&#34;&gt;データベース周りのサポート&lt;/h2&gt;

&lt;p&gt;モデルのジェネレーターや ORM、マイグレーションのサポートを追加しました。&lt;br /&gt;
何故サポートなのかというと、Kocha 固有の ORM を使わないといけないわけではなく、自由に ORM が選べるような実装になっているからです。&lt;/p&gt;

&lt;h3 id=&#34;モデル:a76806e52f0d348474f1d7c3e490e072&#34;&gt;モデル&lt;/h3&gt;

&lt;p&gt;現状では &lt;a href=&#34;https://github.com/naoina/genmai&#34;&gt;genmai&lt;/a&gt; のみのサポートですが、簡単に他の ORM も追加できます。&lt;br /&gt;
モデルのジェネレーターも特定の ORM のものを追加できるようにしていますが、まだ他の ORM 用の実装はしていません。気が向いたら &lt;a href=&#34;https://github.com/coopernurse/gorp&#34;&gt;gorp&lt;/a&gt; 用ぐらいは実装すると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kocha g model user name:string age:int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいにすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type User struct {
    Id   int64  `db:&amp;quot;pk&amp;quot; json:&amp;quot;id&amp;quot;`
    Name string `json:&amp;quot;name&amp;quot;`
    Age  int    `json:&amp;quot;age&amp;quot;`

    genmai.TimeStamp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような struct が書かれたファイルが生成されます。ついでに ORM 固有のインスタンスを取得するヘルパーが書かれたファイルも生成されます。&lt;br /&gt;
まぁここら辺に関してはドキュメント &lt;a href=&#34;http://naoina.github.io/kocha/docs/model.html&#34;&gt;http://naoina.github.io/kocha/docs/model.html&lt;/a&gt; にあっさりですが書いています。&lt;/p&gt;

&lt;h3 id=&#34;マイグレーション:a76806e52f0d348474f1d7c3e490e072&#34;&gt;マイグレーション&lt;/h3&gt;

&lt;p&gt;現時点で私が知っているマイグレーションツールといえば &lt;a href=&#34;https://bitbucket.org/liamstask/goose&#34;&gt;goose&lt;/a&gt; がありますが、ORM を使うときのデータベースの設定と、マイグレーションツールの設定が中身は同じなのに別々に管理しないといけないのが大変好ましくないと考えています。&lt;br /&gt;
ということで、フレームワーク側でマイグレーションをサポートしました。Rails みたいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kocha g migration create_user_table
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でマイグレーションするためのファイルが生成されます。ですが、中身は自分で書かないといけません。Rails みたいにマイグレーション名から自動でマイグレーションの中身を記述するみたいなことはしない方向です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kocha migrate up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で前方向のマイグレーションが走ります。戻したい時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kocha migrate down
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば直近の 1 つのマイグレーションに対してロールバックする処理が走ります。まぁ実際の処理は全部ユーザー側で書かないといけないんですが。&lt;/p&gt;

&lt;h2 id=&#34;環境ごとの設定の廃止:a76806e52f0d348474f1d7c3e490e072&#34;&gt;環境ごとの設定の廃止&lt;/h2&gt;

&lt;p&gt;今まではアプリケーションのトップレベルディレクトリに &lt;code&gt;dev.go&lt;/code&gt; や &lt;code&gt;prod.go&lt;/code&gt;、&lt;code&gt;config/dev.go&lt;/code&gt; や &lt;code&gt;config/prod.go&lt;/code&gt; といった、いわゆる環境ごとの設定セットがありました。&lt;br /&gt;
今回の v0.3 からこれを廃止して、設定は基本的に環境変数によって実行時に指定するように変更しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KOCHA_DB_DRIVER=&amp;quot;mysql&amp;quot; KOCHA_DB_DSN=&amp;quot;user:password@/dbname&amp;quot; kocha run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じになります。一応何も指定しない場合のデフォルトは sqlite3 が指定されてます。&lt;br /&gt;
この変更は &lt;a href=&#34;http://12factor.net/&#34;&gt;The Twelve-Factor App&lt;/a&gt; (&lt;a href=&#34;http://twelve-factor-ja.herokuapp.com/&#34;&gt;日本語訳&lt;/a&gt;) に影響されました。これの &lt;a href=&#34;http://12factor.net/config&#34;&gt;config&lt;/a&gt; (&lt;a href=&#34;http://twelve-factor-ja.herokuapp.com/config&#34;&gt;日本語訳&lt;/a&gt;) に沿った形にしたということになります。&lt;br /&gt;
余談ですが、WEB 系開発者はすべからく The Twelve-Factor App を読むべきだと思います。&lt;/p&gt;

&lt;h2 id=&#34;今後の予定:a76806e52f0d348474f1d7c3e490e072&#34;&gt;今後の予定&lt;/h2&gt;

&lt;p&gt;ある程度なにか WEB サービスが作れそうなぐらいにはなってきたかなという感じです。&lt;br /&gt;
ですが、まだフォーム周りはまともに手を付けてないので、ここを何とかしたら自分自身でドッグフードを食べながらやっていこうかと考えています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最初に公式ドキュメントを当たるべきたった2つの理由</title>
      <link>http://kuune.org/text/2014/03/14/why-you-should-read-official-docs-at-first/</link>
      <pubDate>Fri, 14 Mar 2014 00:41:02 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/03/14/why-you-should-read-official-docs-at-first/</guid>
      <description>

&lt;ol&gt;
&lt;li&gt;ブログ記事は基本更新されないので情報が古いことが多い&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;翻訳されたドキュメントは情報が古いことがとても多い&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ブログ記事は生モノ。時期が経つほど腐る。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:89810c7e568092886620bdd6fe821f4e&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;公式ドキュメント読まないソフトウェアエンジニヤーは何をやってもダメ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang についてそろそろ一言いっとくか</title>
      <link>http://kuune.org/text/2014/02/25/say-a-word-to-golang/</link>
      <pubDate>Tue, 25 Feb 2014 20:46:33 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/02/25/say-a-word-to-golang/</guid>
      <description>&lt;p&gt;&lt;br&gt;&lt;br /&gt;
&lt;span style=&#34;font-size:300%;font-weight:bold;&#34;&gt;最高！！！！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br /&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以下不満&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;struct がどの interface を実装してるか分からない&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reflect&lt;/code&gt; 使っても struct にフィールドとかメソッドを動的に生やせない&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;時間が絡むテストが必要になるたびに &lt;code&gt;var now = time.Now&lt;/code&gt; とかやって &lt;code&gt;now&lt;/code&gt; にモック当てるの辛い&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>書いたコードを捨てる勇気</title>
      <link>http://kuune.org/text/2014/02/21/discard-codes/</link>
      <pubDate>Fri, 21 Feb 2014 20:19:55 &#43;0900</pubDate>
      
      <guid>http://kuune.org/text/2014/02/21/discard-codes/</guid>
      <description>&lt;p&gt;自分の書いたコードに執着せず、どれだけ簡単に捨てられるかがコードの良し悪しに関わってくると思っている。&lt;br /&gt;
例えば 1 日かけて書いたコードを「クソだ」と言って捨てられるか、書いたばかりの 1000 行のコードを「これはダメ」と言って捨てられるかという話。&lt;br /&gt;
コードを捨てない人はとにかくダメなものに継ぎはぎして更にダメなものを作ることに長けている。白に黒を混ぜると黒くなっていくし、黒に黒を足しても黒にしかならない。&lt;/p&gt;

&lt;p&gt;とにかくコードを捨てろ。そしてコードを書け。そして捨てろ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>